\documentclass[12pt]{elsarticle}

%% The following code removes the Elsevier footer.
\makeatletter
\def\ps@pprintTitle{%
    \let\@oddhead\@empty
    \let\@evenhead\@empty
    \def\@oddfoot{\centerline{\thepage}}%
    \let\@evenfoot\@oddfoot}
\makeatother

%% Use the option review to obtain double line spacing
%% \documentclass[preprint,review,12pt]{elsarticle}

%% Use the options 1p,twocolumn; 3p; 3p,twocolumn; 5p; or 5p,twocolumn
%% for a journal layout:
%% \documentclass[final,1p,times]{elsarticle}
%% \documentclass[final,1p,times,twocolumn]{elsarticle}
%% \documentclass[final,3p,times]{elsarticle}
%% \documentclass[final,3p,times,twocolumn]{elsarticle}
%% \documentclass[final,5p,times]{elsarticle}
%% \documentclass[final,5p,times,twocolumn]{elsarticle}

%% Get to see line width.
\usepackage{layouts}
%% The graphicx package provides the includegraphics command.
\usepackage{graphicx}
%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
%% The amsthm package provides extended theorem environments
%% \usepackage{amsthm}

%% The lineno packages adds line numbers. Start line numbering with
%% \begin{linenumbers}, end it with \end{linenumbers}. Or switch it on
%% for the whole article with \linenumbers after \end{frontmatter}.
\usepackage{lineno}

% A better font.
\usepackage[charter]{mathdesign}
% \def\rmdefault{bch} % not scaled
% \def\ttdefault{blg}
\usepackage{inconsolata}

%% natbib.sty is loaded by default. However, natbib options can be
%% provided with \biboptions{...} command. Following options are
%% valid:

%%   round  -  round parentheses are used (default)
%%   square -  square brackets are used   [option]
%%   curly  -  curly braces are used      {option}
%%   angle  -  angle brackets are used    <option>
%%   semicolon  -  multiple citations separated by semi-colon
%%   colon  - same as semicolon, an earlier confusion
%%   comma  -  separated by comma
%%   numbers-  selects numerical citations
%%   super  -  numerical citations as superscripts
%%   sort   -  sorts multiple citations according to order in ref. list
%%   sort&compress   -  like sort, but also compresses numerical citations
%%   compress - compresses without sorting
%%
%% \biboptions{comma,round}

%% \biboptions{}

%% \journal{Journal Name}

\begin{document}

\begin{frontmatter}

    %% Title, authors and addresses

    \title{A Performance Comparison Between Unbalanced Binary Search Trees and AVL Trees}

    %% use the tnoteref command within \title for footnotes;
    %% use the tnotetext command for the associated footnote;
    %% use the fnref command within \author or \address for footnotes;
    %% use the fntext command for the associated footnote;
    %% use the corref command within \author for corresponding author footnotes;
    %% use the cortext command for the associated footnote;
    %% use the ead command for the email address,
    %% and the form \ead[url] for the home page:
    %%
    %% \title{Title\tnoteref{label1}}
    %% \tnotetext[label1]{}
    %% \author{Name\corref{cor1}\fnref{label2}}
    %% \ead[url]{home page}
    %% \fntext[label2]{}
    %% \cortext[cor1]{}
    %% \address{Address\fnref{label3}}
    %% \fntext[label3]{}


    %% use optional labels to link authors explicitly to addresses:
    %% \author[label1,label2]{<author name>}
    %% \address[label1]{<address>}
    %% \address[label2]{<address>}

    \author{Bernardo Sulzbach}
    \ead{mafagafogigante@gmail.com}

    \author{Leonardo Ferrazza}

    \address{Rio Grande do Sul, Brazil}

    \begin{abstract}
    This paper compares the performance of insertions, deletions and queries of
    varying sizes on both unbalanced binary search trees and AVL trees using
    both unsorted and sorted data.
    \end{abstract}

    \begin{keyword}
        Computer Science \sep Data Structures \sep Performance
    \end{keyword}

\end{frontmatter}

% \linenumbers

\section{Introduction}

\subsection{Differences}

Queries on AVL trees are identical to queries on any unbalanced binary search
tree (BST). However, because the height of the tree is bound, the number of
comparisons tends to be smaller for large enough \(n\).

Insertions on AVL trees are more complex than insertions on unbalanced BSTs.
This is a consequence of the need to preserve the tree balance.

Removal on AVL trees is also more complex than removal on unbalanced BSTs, as
removing nodes may lead to an unbalanced AVL tree and, therefore, trigger a
rebalancing operation.

\subsection{Experiments Description}

We have implemented both an unbalanced BST and an AVL tree using ISO C and
compared both performance-wise using data sets of unsorted (shuffled) and sorted
32-bit integers.

Details regarding compiler version, compiler flags and execution environment
may be found in \ref{ap:ENV}.

\section{Expected Results}

It is expected that the balanced tree will outperform its unbalanced analogous
for large enough \(n\). Sorted input should make the difference substantially
more evident as the insertion complexity for the unbalanced BST degenerates to
\(\Theta\left(n^2\right)\) as the tree will behave as a linked list.

AVL trees are more rigidly balanced than red-black trees, leading to faster
retrieval, at the cost of slower insertion and deletion. However, as the main
objective is to compare the performance differences between unbalanced BSTs and
balanced BSTs, both AVL trees or RB trees are viable representatives of
balanced BSTs.

\section{Experimental Results}

\subsection{Unordered Input}
\subsubsection{Insertion}
\begin{center}\includegraphics[width=\linewidth]{assets/insertion-duration.png}\end{center}
\begin{center}\includegraphics[width=\linewidth]{assets/insertion-comparisons.png}\end{center}
\subsubsection{Query}
\begin{center}\includegraphics[width=\linewidth]{assets/query-duration.png}\end{center}
\begin{center}\includegraphics[width=\linewidth]{assets/query-comparisons.png}\end{center}
\subsubsection{Removal}
\begin{center}\includegraphics[width=\linewidth]{assets/removal-duration.png}\end{center}
\begin{center}\includegraphics[width=\linewidth]{assets/removal-comparisons.png}\end{center}

\subsection{Sorted Input}
\subsubsection{Insertion}
\begin{center}\includegraphics[width=\linewidth]{assets/sorted-insertion-duration.png}\end{center}
\begin{center}\includegraphics[width=\linewidth]{assets/sorted-insertion-comparisons.png}\end{center}
\subsubsection{Query}
\begin{center}\includegraphics[width=\linewidth]{assets/sorted-query-duration.png}\end{center}
\begin{center}\includegraphics[width=\linewidth]{assets/sorted-query-comparisons.png}\end{center}
\subsubsection{Removal}
\begin{center}\includegraphics[width=\linewidth]{assets/sorted-removal-duration.png}\end{center}
\begin{center}\includegraphics[width=\linewidth]{assets/sorted-removal-comparisons.png}\end{center}

\section{Conclusions}

Based on the experimental results it can be concluded that for most real-world
scenarios, balanced binary search trees such as AVL trees and RB trees are a
better choice. The increased code complexity of the insertion and removal
operations pays off as the average operation duration is lowered, improving
overall application performance except when \(n < 10\), where both balanced and
unbalanced trees perform similarly.

\appendix

\section{Execution Environment} \label{ap:ENV}

The compiler used was a 64-bit packaged build of GCC 5.3.1.

The compilation flags were \texttt{-std=c89}, \texttt{-O3}, and
\texttt{-DNDEBUG}.

Profiling was performed on a workstation with the following specifications:
\begin{itemize}
    \item Fedora Workstation 23 64-bit with Kernel 4.7.10-100
    \item AMD FX-8320E Eight-Core Processor (8M cache, 3.2 GHz)
    \item 32 GB (4 x 8 GB) of 1600 MHz RAM
\end{itemize}

\end{document}
